trigger:
  branches:
    include: [main]
  paths:
    include: ['terraform/**']

pr:
  branches:
    include: [main]
  paths:
    include: ['terraform/**']

parameters:
  - name: environment
    displayName: Target Environment
    type: string
    default: dev
    values: [dev, test, prod]

variables:
  - group: terraform-common         # TF_STATE_RG, TF_STATE_SA, TF_STATE_CONTAINER
  - group: terraform-${{ parameters.environment }}  # CONNECTOR_API_KEY, env secrets
  - name: TF_VERSION
    value: '1.7.5'
  - name: WORKING_DIR
    value: '$(System.DefaultWorkingDirectory)/terraform'
  - name: ENVIRONMENT
    value: ${{ parameters.environment }}

stages:
  # â”€â”€ Stage 1: Validate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - stage: Validate
    displayName: 'âœ… Validate'
    jobs:
      - job: ValidateJob
        displayName: Terraform Format & Validate
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: TerraformInstaller@1
            displayName: Install Terraform $(TF_VERSION)
            inputs:
              terraformVersion: $(TF_VERSION)

          - task: TerraformTaskV4@4
            displayName: Terraform Init
            inputs:
              provider: azurerm
              command: init
              workingDirectory: $(WORKING_DIR)
              backendServiceArm: AzureServiceConnection
              backendAzureRmResourceGroupName: $(TF_STATE_RG)
              backendAzureRmStorageAccountName: $(TF_STATE_SA)
              backendAzureRmContainerName: $(TF_STATE_CONTAINER)
              backendAzureRmKey: $(ENVIRONMENT).tfstate

          - bash: terraform fmt -check -recursive
            displayName: Terraform Format Check
            workingDirectory: $(WORKING_DIR)

          - task: TerraformTaskV4@4
            displayName: Terraform Validate
            inputs:
              provider: azurerm
              command: validate
              workingDirectory: $(WORKING_DIR)

  # â”€â”€ Stage 2: Plan â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - stage: Plan
    displayName: 'ðŸ“‹ Plan: $(ENVIRONMENT)'
    dependsOn: Validate
    jobs:
      - job: PlanJob
        displayName: Terraform Plan
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: TerraformInstaller@1
            inputs:
              terraformVersion: $(TF_VERSION)

          - task: TerraformTaskV4@4
            displayName: Terraform Init
            inputs:
              provider: azurerm
              command: init
              workingDirectory: $(WORKING_DIR)
              backendServiceArm: AzureServiceConnection
              backendAzureRmResourceGroupName: $(TF_STATE_RG)
              backendAzureRmStorageAccountName: $(TF_STATE_SA)
              backendAzureRmContainerName: $(TF_STATE_CONTAINER)
              backendAzureRmKey: $(ENVIRONMENT).tfstate

          - task: TerraformTaskV4@4
            displayName: Terraform Plan
            inputs:
              provider: azurerm
              command: plan
              workingDirectory: $(WORKING_DIR)
              commandOptions: >
                -var-file="environments/$(ENVIRONMENT).tfvars"
                -var="connector_api_key=$(CONNECTOR_API_KEY)"
                -out=$(Pipeline.Workspace)/tfplan
                -detailed-exitcode
              environmentServiceNameAzureRM: AzureServiceConnection

          - task: PublishPipelineArtifact@1
            displayName: Publish Plan Artifact
            inputs:
              targetPath: $(Pipeline.Workspace)/tfplan
              artifact: tfplan-$(ENVIRONMENT)

  # â”€â”€ Stage 3: Apply â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - stage: Apply
    displayName: 'ðŸš€ Apply: $(ENVIRONMENT)'
    dependsOn: Plan
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - deployment: ApplyJob
        displayName: Apply Infrastructure
        pool:
          vmImage: ubuntu-latest
        environment: $(ENVIRONMENT)     # ðŸ”’ Approval gate configured in ADO Environments
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: TerraformInstaller@1
                  inputs:
                    terraformVersion: $(TF_VERSION)

                - task: DownloadPipelineArtifact@2
                  displayName: Download Plan Artifact
                  inputs:
                    artifactName: tfplan-$(ENVIRONMENT)
                    targetPath: $(WORKING_DIR)

                - task: TerraformTaskV4@4
                  displayName: Terraform Init
                  inputs:
                    provider: azurerm
                    command: init
                    workingDirectory: $(WORKING_DIR)
                    backendServiceArm: AzureServiceConnection
                    backendAzureRmResourceGroupName: $(TF_STATE_RG)
                    backendAzureRmStorageAccountName: $(TF_STATE_SA)
                    backendAzureRmContainerName: $(TF_STATE_CONTAINER)
                    backendAzureRmKey: $(ENVIRONMENT).tfstate

                - task: TerraformTaskV4@4
                  displayName: Terraform Apply
                  inputs:
                    provider: azurerm
                    command: apply
                    workingDirectory: $(WORKING_DIR)
                    commandOptions: -auto-approve tfplan
                    environmentServiceNameAzureRM: AzureServiceConnection

                - bash: |
                    cd $(WORKING_DIR)
                    FUNC_URL=$(terraform output -raw function_app_hostname 2>/dev/null || echo "")
                    KV_URI=$(terraform output -raw key_vault_uri)
                    APIM_URL=$(terraform output -raw apim_gateway_url 2>/dev/null || echo "")
                    echo "##vso[task.setvariable variable=FunctionAppUrl;isOutput=true]https://$FUNC_URL"
                    echo "##vso[task.setvariable variable=KeyVaultUri;isOutput=true]$KV_URI"
                    echo "##vso[task.setvariable variable=ApimGatewayUrl;isOutput=true]$APIM_URL"
                  displayName: Export Terraform Outputs
                  name: TerraformOutputs

  # â”€â”€ Stage 4: Deploy Power Platform Solution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  - stage: DeployPowerPlatform
    displayName: 'âš¡ Deploy PP Solution: $(ENVIRONMENT)'
    dependsOn: Apply
    variables:
      FunctionAppUrl: $[ stageDependencies.Apply.ApplyJob.outputs['ApplyJob.TerraformOutputs.FunctionAppUrl'] ]
      KeyVaultUri: $[ stageDependencies.Apply.ApplyJob.outputs['ApplyJob.TerraformOutputs.KeyVaultUri'] ]
    jobs:
      - job: DeployJob
        displayName: Import Power Platform Solution
        pool:
          vmImage: ubuntu-latest
        steps:
          - task: PowerPlatformToolInstaller@2
            displayName: Install Power Platform CLI
            inputs:
              DefaultVersion: true

          - task: PowerPlatformImportSolution@2
            displayName: Import Solution
            inputs:
              authenticationType: PowerPlatformSPN
              PowerPlatformSPN: PowerPlatformServiceConnection
              Environment: $(PP_ENVIRONMENT_URL)
              SolutionInputFile: $(Pipeline.Workspace)/MySolution.zip
              AsyncOperation: true
              MaxAsyncWaitTime: 60
